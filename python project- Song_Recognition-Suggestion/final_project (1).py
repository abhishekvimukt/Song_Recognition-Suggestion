# -*- coding: utf-8 -*-
"""final_project.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1zLwyN_E0e3iUtL7Fyh0VmJGA7HHd4dPl
"""

!pip  install pydub
!pip install shazamAPI
!pip install spotipy

from pydub import AudioSegment

sound = AudioSegment.from_wav("input.wav")
sound.export("output.mp3", format="mp3")
from ShazamAPI import Shazam
import json


mp3_file_content_to_recognize = open('output.mp3', 'rb').read()

shazam = Shazam(mp3_file_content_to_recognize)
recognize_generator = shazam.recognizeSong()
for r in recognize_generator:
    A = json.dumps(r,indent = 2)
d = json.loads(A)
t = d[1]["track"]["title"]
a = d[1]["track"]["subtitle"]

print(t, a)

import requests

CLIENT_ID = '549e7745d08c4b799daa0234b50a1cfd'
CLIENT_SECRET = 'e183e4688ecd47019b24e07868eaf437'

AUTH_URL = 'https://accounts.spotify.com/api/token'

# POST
auth_response = requests.post(AUTH_URL, {
    'grant_type': 'client_credentials',
    'client_id': CLIENT_ID,
    'client_secret': CLIENT_SECRET,
})

# convert the response to JSON
auth_response_data = auth_response.json()

# save the access token
access_token = auth_response_data['access_token']


headers = {
    'Authorization': 'Bearer {token}'.format(token=access_token)
}

import spotipy
sp = spotipy.Spotify(headers)

results = sp.search(q='artist:' + a + ' track:' + t, type='track')
if results['tracks']['items']:
    trackId = results['tracks']['items'][0]['id']
    print(trackId)
else:
    print("No matching tracks found.")




BASE_URL = 'https://api.spotify.com/v1/'

#Track ID from the URI


#actual GET request with proper header
r = requests.get(BASE_URL + 'audio-features/' + trackId , headers=headers)
r = r.json()
r

import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
import seaborn as sb

from sklearn.metrics.pairwise import cosine_similarity
from sklearn.feature_extraction.text import CountVectorizer
from sklearn.manifold import TSNE

import warnings
warnings.filterwarnings('ignore')
tracks = pd.read_csv('dataset.csv')

tracks.dropna(inplace = True)

tracks = tracks.drop('track_id', axis = 1)

a = tracks.select_dtypes(include=np.number)

tracks = tracks.sort_values(by=['popularity'], ascending=False)
tracks.drop_duplicates(subset=['track_name'], keep='first', inplace=True)


song_vectorizer = CountVectorizer()
song_vectorizer.fit(tracks['track_genre'])

tracks = tracks.sort_values(by=['popularity'], ascending=False).head(10000)


def get_similarities(song_name, data):
   
  # Getting vector for the input song.
  text_array1 = song_vectorizer.transform(data[data['track_name']==song_name]['track_genre']).toarray()
  num_array1 = data[data['track_name']==song_name].select_dtypes(include=np.number).to_numpy()
   
  # We will store similarity for each row of the dataset.
  sim = []
  for idx, row in data.iterrows():
    name = row['track_name']
     
    # Getting vector for current song.
    text_array2 = song_vectorizer.transform(data[data['track_name']==name]['track_genre']).toarray()
    num_array2 = data[data['track_name']==name].select_dtypes(include=np.number).to_numpy()
 
    # Calculating similarities for text as well as numeric features
    text_sim = cosine_similarity(text_array1, text_array2)[0][0]
    num_sim = cosine_similarity(num_array1, num_array2)[0][0]
    sim.append(text_sim + num_sim)
     
  return sim



def recommend_songs(song_name, data=tracks):
# Base case
  if tracks[tracks['track_name'] == song_name].shape[0] == 0:
    print('This song is either not so popular or you\\have entered invalid_name.\\n Some songs you may like:\\n')
    
    for song in data.sample(n=5)['track_name'].values:
      print(song)
    return

  data['similarity_factor'] = get_similarities(song_name, data)

  data.sort_values(by=['similarity_factor', 'popularity'],
                  ascending = [False, False],
                  inplace=True)

  # First song will be the input song itself as the similarity will be highest.
  display(data[['track_name', 'artists']][2:7])

recommend_songs(t)

